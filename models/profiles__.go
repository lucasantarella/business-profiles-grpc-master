package models

/*---------------------------+
| Code generated by modelgen |
|        DO NOT EDIT.        |
+---------------------------*/

// If you want to extend behaviour:
// Please create a custom file in this directory
// and create the methods there to avoid overwriting your code with the generated one.

import (
	"fmt"
	pb "github.com/lucasantarella/business-profiles-grpc-golib"
)

const (
	selectProfiles = "`id`, `user_id`, `first_name`, `last_name`, `email`, `profile_url`"
)

// Profiles represents a row in the profiles__ table
type Profiles struct {
	ID         int64  `json:"id"`
	UserID     int64  `json:"user_id"`
	FirstName  string `json:"first_name"`
	LastName   string `json:"last_name"`
	Email      string `json:"email"`
	ProfileURL string `json:"profile_url"`
	offset     int
	limit      int
}

// Insert a new Profiles row in the profiles__ table
func (p *Profiles) Insert(qu Queryer) (lastInsertID int64, err error) {
	const stmt = "INSERT INTO `profiles__` (`user_id`, `first_name`, `last_name`, `email`, `profile_url`) VALUES (?, ?, ?, ?, ?)"
	res, err := qu.Exec(stmt, p.UserID, p.FirstName, p.LastName, p.Email, p.ProfileURL)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

// Update an existing Profiles row in the profiles__ table.
func (p *Profiles) Update(qu Queryer, id int64) (int64, error) {
	const stmt = "UPDATE `profiles__` SET `user_id`=?, `first_name`=?, `last_name`=?, `email`=?, `profile_url`=? WHERE id = ?"
	result, err := qu.Exec(stmt, p.UserID, p.FirstName, p.LastName, p.Email, p.ProfileURL, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

// Upsert inserts a new Profiles row in the profiles__ table
// if the unique constraints are not found, otherwise it updates it.
func (p *Profiles) Upsert(qu Queryer) (lastInsertID int64, err error) {
	const stmt = "INSERT INTO `profiles__` (`id`, `user_id`, `first_name`, `last_name`, `email`, `profile_url`) VALUES (?, ?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE `id`=LAST_INSERT_ID(`id`), `first_name`=VALUES(`first_name`), `last_name`=VALUES(`last_name`), `email`=VALUES(`email`), `profile_url`=VALUES(`profile_url`)"
	res, err := qu.Exec(stmt, p.ID, p.UserID, p.FirstName, p.LastName, p.Email, p.ProfileURL)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

// Find an existing Profiles row in the profiles__ table
func (p *Profiles) Find(qu Queryer, id int64) error {
	const stmt = "SELECT " + selectProfiles + " FROM `profiles__` WHERE id = ?"
	row := qu.QueryRow(stmt, id)
	return row.Scan(&p.ID, &p.UserID, &p.FirstName, &p.LastName, &p.Email, &p.ProfileURL)
}

// Load all, or a subset of Profiles rows from the profiles__ table
func (p *Profiles) Load(qu Queryer) (set []Profiles, err error) {
	stmt := "SELECT " + selectProfiles + " FROM `profiles__`"

	if p.limit == 0 && p.offset > 0 {
		return set, fmt.Errorf("cannot query with offset but no limit")
	}

	if p.limit > 0 {
		stmt += fmt.Sprintf(" LIMIT %d", p.limit)
	}
	if p.offset > 0 {
		stmt += fmt.Sprintf(" OFFSET %d", p.offset)
	}
	defer func() {
		p.limit = 0
		p.offset = 0
	}()
	rows, err := qu.Query(stmt)
	if err != nil {
		return
	}
	defer rows.Close()
	for rows.Next() {
		var p Profiles
		if err = rows.Scan(&p.ID, &p.FirstName, &p.LastName, &p.Email, &p.ProfileURL); err != nil {
			return
		}
		set = append(set, p)
	}

	return
}

// Delete an existing Profiles row from the profiles__ table
func (p *Profiles) Delete(qu Queryer, id int64) (rowsAffected int64, err error) {
	const stmt = "DELETE FROM `profiles__` WHERE id = ?"
	result, err := qu.Exec(stmt, id)
	if err != nil {
		return
	}

	return result.RowsAffected()
}

// Count the number of rows from the profiles__ table
func (p *Profiles) Count(qu Queryer) (count int64, err error) {
	const stmt = "SELECT COUNT(*) FROM `profiles__`"
	row := qu.QueryRow(stmt)
	if err = row.Scan(&count); err != nil {
		return
	}
	return
}

// Exists checks for the items existence in the database, based on it's id.
// An error will only be returned if a SQL related failure happens.
// In all other cases, a bool and nil will return.
func (p *Profiles) Exists(qu Queryer, id int64) (exists bool, err error) {
	const stmt = "SELECT EXISTS(SELECT 1 FROM `profiles__` WHERE id = ? LIMIT 1) AS `exists`"
	var count int
	row := qu.QueryRow(stmt, id)
	if err = row.Scan(&count); err != nil {
		return
	}
	return count > 0, nil
}

// TableName returns the table name
func (p *Profiles) TableName() string {
	return "profiles__"
}

// SetLimit sets the query limit
func (p *Profiles) SetLimit(limit int) *Profiles {
	p.limit = limit
	return p
}

// SetOffset sets the query offset
func (p *Profiles) SetOffset(offset int) *Profiles {
	p.offset = offset
	return p
}

func (p *Profiles) ToPbProfile() *pb.Profile {
	return &pb.Profile{
		Id:                uint64(p.ID),
		FirstName:         p.FirstName,
		LastName:          p.LastName,
		Email:             p.Email,
		ProfilePictureUrl: p.ProfileURL,
	}
}
