package models

/*---------------------------+
| Code generated by modelgen |
|        DO NOT EDIT.        |
+---------------------------*/

// If you want to extend behaviour:
// Please create a custom file in this directory
// and create the methods there to avoid overwriting your code with the generated one.

import (
	"fmt"
)

const (
	selectProfilesSocial = "`profiles__social__`.`id`, `profiles__social__`.`profile_id`, `profiles__social__`.`type`, `profiles__social__`.`value`"
)

// ProfilesSocial represents a row in the profiles__social__ table
type ProfilesSocial struct {
	ID        int64      `json:"id"`
	ProfileID int64      `json:"profile_id"`
	Type      int64      `json:"type"`
	Value     NullString `json:"value"`
	offset    int
	limit     int
}

// Insert a new ProfilesSocial row in the profiles__social__ table
func (p *ProfilesSocial) Insert(qu Queryer) (lastInsertID int64, err error) {
	const stmt = "INSERT INTO `profiles__social__` (`profile_id`, `type`, `value`) VALUES (?, ?, ?)"
	res, err := qu.Exec(stmt, p.ProfileID, p.Type, p.Value)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

// Update an existing ProfilesSocial row in the profiles__social__ table.
func (p *ProfilesSocial) Update(qu Queryer, id int64) (int64, error) {
	const stmt = "UPDATE `profiles__social__` SET `profile_id`=?, `type`=?, `value`=? WHERE id = ?"
	result, err := qu.Exec(stmt, p.ProfileID, p.Type, p.Value, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

// Upsert inserts a new ProfilesSocial row in the profiles__social__ table
// if the unique constraints are not found, otherwise it updates it.
func (p *ProfilesSocial) Upsert(qu Queryer) (lastInsertID int64, err error) {
	const stmt = "INSERT INTO `profiles__social__` (`id`, `profile_id`, `type`, `value`) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE `id`=LAST_INSERT_ID(`id`), `profile_id`=VALUES(`profile_id`), `type`=VALUES(`type`), `value`=VALUES(`value`)"
	res, err := qu.Exec(stmt, p.ID, p.ProfileID, p.Type, p.Value)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

// Find an existing ProfilesSocial row in the profiles__social__ table
func (p *ProfilesSocial) Find(qu Queryer, id int64) error {
	const stmt = "SELECT " + selectProfilesSocial + " FROM `profiles__social__` WHERE id = ?"
	row := qu.QueryRow(stmt, id)
	return row.Scan(&p.ID, &p.ProfileID, &p.Type, &p.Value)
}

// Find an existing ProfilesSocial row in the profiles__social__ table
func (p *ProfilesSocial) FindByProfileID(qu Queryer, profile_id int64) (set []ProfilesSocial, err error) {
	stmt := fmt.Sprintf("SELECT "+selectProfilesSocial+" FROM `profiles__social__` INNER JOIN `profiles__` ON `profiles__`.`id` = `profiles__social__`.`profile_id` WHERE `profiles__social__`.`profile_id` = %d", profile_id)

	if p.limit == 0 && p.offset > 0 {
		return set, fmt.Errorf("cannot query with offset but no limit")
	}

	if p.limit > 0 {
		stmt += fmt.Sprintf(" LIMIT %d", p.limit)
	}
	if p.offset > 0 {
		stmt += fmt.Sprintf(" OFFSET %d", p.offset)
	}
	defer func() {
		p.limit = 0
		p.offset = 0
	}()
	rows, err := qu.Query(stmt)
	if err != nil {
		return
	}
	defer rows.Close()
	for rows.Next() {
		var p ProfilesSocial
		if err = rows.Scan(&p.ID, &p.ProfileID, &p.Type, &p.Value); err != nil {
			return
		}
		set = append(set, p)
	}

	return
}

// Load all, or a subset of ProfilesSocial rows from the profiles__social__ table
func (p *ProfilesSocial) Load(qu Queryer) (set []ProfilesSocial, err error) {
	stmt := "SELECT " + selectProfilesSocial + " FROM `profiles__social__`"

	if p.limit == 0 && p.offset > 0 {
		return set, fmt.Errorf("cannot query with offset but no limit")
	}

	if p.limit > 0 {
		stmt += fmt.Sprintf(" LIMIT %d", p.limit)
	}
	if p.offset > 0 {
		stmt += fmt.Sprintf(" OFFSET %d", p.offset)
	}
	defer func() {
		p.limit = 0
		p.offset = 0
	}()
	rows, err := qu.Query(stmt)
	if err != nil {
		return
	}
	defer rows.Close()
	for rows.Next() {
		var p ProfilesSocial
		if err = rows.Scan(&p.ID, &p.ProfileID, &p.Type, &p.Value); err != nil {
			return
		}
		set = append(set, p)
	}

	return
}

// Delete an existing ProfilesSocial row from the profiles__social__ table
func (p *ProfilesSocial) Delete(qu Queryer, id int64) (rowsAffected int64, err error) {
	const stmt = "DELETE FROM `profiles__social__` WHERE id = ?"
	result, err := qu.Exec(stmt, id)
	if err != nil {
		return
	}

	return result.RowsAffected()
}

// Count the number of rows from the profiles__social__ table
func (p *ProfilesSocial) Count(qu Queryer) (count int64, err error) {
	const stmt = "SELECT COUNT(*) FROM `profiles__social__`"
	row := qu.QueryRow(stmt)
	if err = row.Scan(&count); err != nil {
		return
	}
	return
}

// Exists checks for the items existence in the database, based on it's id.
// An error will only be returned if a SQL related failure happens.
// In all other cases, a bool and nil will return.
func (p *ProfilesSocial) Exists(qu Queryer, id int64) (exists bool, err error) {
	const stmt = "SELECT EXISTS(SELECT 1 FROM `profiles__social__` WHERE id = ? LIMIT 1) AS `exists`"
	var count int
	row := qu.QueryRow(stmt, id)
	if err = row.Scan(&count); err != nil {
		return
	}
	return count > 0, nil
}

// TableName returns the table name
func (p *ProfilesSocial) TableName() string {
	return "profiles__social__"
}

// SetLimit sets the query limit
func (p *ProfilesSocial) SetLimit(limit int) *ProfilesSocial {
	p.limit = limit
	return p
}

// SetOffset sets the query offset
func (p *ProfilesSocial) SetOffset(offset int) *ProfilesSocial {
	p.offset = offset
	return p
}
