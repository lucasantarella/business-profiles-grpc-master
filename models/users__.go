package models

/*---------------------------+
| Code generated by modelgen |
|        DO NOT EDIT.        |
+---------------------------*/

// If you want to extend behaviour:
// Please create a custom file in this directory
// and create the methods there to avoid overwriting your code with the generated one.

import (
	"fmt"
)

const (
	selectUsers = "`id`, `username`, `email`, `password`"
)

// Users represents a row in the users__ table
type Users struct {
	ID       int64  `json:"id"`
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
	offset   int
	limit    int
}

// Insert a new Users row in the users__ table
func (u *Users) Insert(qu Queryer) (lastInsertID int64, err error) {
	const stmt = "INSERT INTO `users__` (`username`, `email`, `password`) VALUES (?, ?, ?)"
	res, err := qu.Exec(stmt, u.Username, u.Email, u.Password)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

// Update an existing Users row in the users__ table.
func (u *Users) Update(qu Queryer, id int64) (int64, error) {
	const stmt = "UPDATE `users__` SET `username`=?, `email`=?, `password`=? WHERE id = ?"
	result, err := qu.Exec(stmt, u.Username, u.Email, u.Password, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

// Upsert inserts a new Users row in the users__ table
// if the unique constraints are not found, otherwise it updates it.
func (u *Users) Upsert(qu Queryer) (lastInsertID int64, err error) {
	const stmt = "INSERT INTO `users__` (`id`, `username`, `email`, `password`) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE `id`=LAST_INSERT_ID(`id`), `username`=VALUES(`username`), `email`=VALUES(`email`), `password`=VALUES(`password`)"
	res, err := qu.Exec(stmt, u.ID, u.Username, u.Email, u.Password)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

// Find an existing Users row in the users__ table
func (u *Users) Find(qu Queryer, id int64) error {
	const stmt = "SELECT " + selectUsers + " FROM `users__` WHERE id = ?"
	row := qu.QueryRow(stmt, id)
	return row.Scan(&u.ID, &u.Username, &u.Email, &u.Password)
}

// Load all, or a subset of Users rows from the users__ table
func (u *Users) Load(qu Queryer) (set []Users, err error) {
	stmt := "SELECT " + selectUsers + " FROM `users__`"

	if u.limit == 0 && u.offset > 0 {
		return set, fmt.Errorf("cannot query with offset but no limit")
	}

	if u.limit > 0 {
		stmt += fmt.Sprintf(" LIMIT %d", u.limit)
	}
	if u.offset > 0 {
		stmt += fmt.Sprintf(" OFFSET %d", u.offset)
	}
	defer func() {
		u.limit = 0
		u.offset = 0
	}()
	rows, err := qu.Query(stmt)
	if err != nil {
		return
	}
	defer rows.Close()
	for rows.Next() {
		var u Users
		if err = rows.Scan(&u.ID, &u.Username, &u.Email, &u.Password); err != nil {
			return
		}
		set = append(set, u)
	}

	return
}

// Delete an existing Users row from the users__ table
func (u *Users) Delete(qu Queryer, id int64) (rowsAffected int64, err error) {
	const stmt = "DELETE FROM `users__` WHERE id = ?"
	result, err := qu.Exec(stmt, id)
	if err != nil {
		return
	}

	return result.RowsAffected()
}

// Count the number of rows from the users__ table
func (u *Users) Count(qu Queryer) (count int64, err error) {
	const stmt = "SELECT COUNT(*) FROM `users__`"
	row := qu.QueryRow(stmt)
	if err = row.Scan(&count); err != nil {
		return
	}
	return
}

// Exists checks for the items existence in the database, based on it's id.
// An error will only be returned if a SQL related failure happens.
// In all other cases, a bool and nil will return.
func (u *Users) Exists(qu Queryer, id int64) (exists bool, err error) {
	const stmt = "SELECT EXISTS(SELECT 1 FROM `users__` WHERE id = ? LIMIT 1) AS `exists`"
	var count int
	row := qu.QueryRow(stmt, id)
	if err = row.Scan(&count); err != nil {
		return
	}
	return count > 0, nil
}

// TableName returns the table name
func (u *Users) TableName() string {
	return "users__"
}

// SetLimit sets the query limit
func (u *Users) SetLimit(limit int) *Users {
	u.limit = limit
	return u
}

// SetOffset sets the query offset
func (u *Users) SetOffset(offset int) *Users {
	u.offset = offset
	return u
}
