package models

/*---------------------------+
| Code generated by modelgen |
|        DO NOT EDIT.        |
+---------------------------*/

// If you want to extend behaviour:
// Please create a custom file in this directory
// and create the methods there to avoid overwriting your code with the generated one.

import (
	"fmt"
)

const (
	selectProfilesExperiences = "`id`, `profile_id`, `start`, `end`, `role`, `tag_line`, `description`"
)

// ProfilesExperiences represents a row in the profiles__experiences__ table
type ProfilesExperiences struct {
	ID          int64     `json:"id"`
	ProfileID   int64     `json:"profile_id"`
	Start       int64     `json:"start"`
	End         NullInt64 `json:"end"`
	Role        string    `json:"role"`
	TagLine     string    `json:"tag_line"`
	Description string    `json:"description"`
	offset      int
	limit       int
}

// Insert a new ProfilesExperiences row in the profiles__experiences__ table
func (p *ProfilesExperiences) Insert(qu Queryer) (lastInsertID int64, err error) {
	const stmt = "INSERT INTO `profiles__experiences__` (`profile_id`, `start`, `end`, `role`, `tag_line`, `description`) VALUES (?, ?, ?, ?, ?, ?)"
	res, err := qu.Exec(stmt, p.ProfileID, p.Start, p.End, p.Role, p.TagLine, p.Description)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

// Update an existing ProfilesExperiences row in the profiles__experiences__ table.
func (p *ProfilesExperiences) Update(qu Queryer, id int64) (int64, error) {
	const stmt = "UPDATE `profiles__experiences__` SET `profile_id`=?, `start`=?, `end`=?, `role`=?, `tag_line`=?, `description`=? WHERE id = ?"
	result, err := qu.Exec(stmt, p.ProfileID, p.Start, p.End, p.Role, p.TagLine, p.Description, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

// Upsert inserts a new ProfilesExperiences row in the profiles__experiences__ table
// if the unique constraints are not found, otherwise it updates it.
func (p *ProfilesExperiences) Upsert(qu Queryer) (lastInsertID int64, err error) {
	const stmt = "INSERT INTO `profiles__experiences__` (`id`, `profile_id`, `start`, `end`, `role`, `tag_line`, `description`) VALUES (?, ?, ?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE `id`=LAST_INSERT_ID(`id`), `profile_id`=VALUES(`profile_id`), `start`=VALUES(`start`), `end`=VALUES(`end`), `role`=VALUES(`role`), `tag_line`=VALUES(`tag_line`), `description`=VALUES(`description`)"
	res, err := qu.Exec(stmt, p.ID, p.ProfileID, p.Start, p.End, p.Role, p.TagLine, p.Description)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

// Find an existing ProfilesExperiences row in the profiles__experiences__ table
func (p *ProfilesExperiences) Find(qu Queryer, id int64) error {
	const stmt = "SELECT " + selectProfilesExperiences + " FROM `profiles__experiences__` WHERE id = ?"
	row := qu.QueryRow(stmt, id)
	return row.Scan(&p.ID, &p.ProfileID, &p.Start, &p.End, &p.Role, &p.TagLine, &p.Description)
}

// Load all, or a subset of ProfilesExperiences rows from the profiles__experiences__ table
func (p *ProfilesExperiences) Load(qu Queryer) (set []ProfilesExperiences, err error) {
	stmt := "SELECT " + selectProfilesExperiences + " FROM `profiles__experiences__`"

	if p.limit == 0 && p.offset > 0 {
		return set, fmt.Errorf("cannot query with offset but no limit")
	}

	if p.limit > 0 {
		stmt += fmt.Sprintf(" LIMIT %d", p.limit)
	}
	if p.offset > 0 {
		stmt += fmt.Sprintf(" OFFSET %d", p.offset)
	}
	defer func() {
		p.limit = 0
		p.offset = 0
	}()
	rows, err := qu.Query(stmt)
	if err != nil {
		return
	}
	defer rows.Close()
	for rows.Next() {
		var p ProfilesExperiences
		if err = rows.Scan(&p.ID, &p.ProfileID, &p.Start, &p.End, &p.Role, &p.TagLine, &p.Description); err != nil {
			return
		}
		set = append(set, p)
	}

	return
}

// Delete an existing ProfilesExperiences row from the profiles__experiences__ table
func (p *ProfilesExperiences) Delete(qu Queryer, id int64) (rowsAffected int64, err error) {
	const stmt = "DELETE FROM `profiles__experiences__` WHERE id = ?"
	result, err := qu.Exec(stmt, id)
	if err != nil {
		return
	}

	return result.RowsAffected()
}

// Count the number of rows from the profiles__experiences__ table
func (p *ProfilesExperiences) Count(qu Queryer) (count int64, err error) {
	const stmt = "SELECT COUNT(*) FROM `profiles__experiences__`"
	row := qu.QueryRow(stmt)
	if err = row.Scan(&count); err != nil {
		return
	}
	return
}

// Exists checks for the items existence in the database, based on it's id.
// An error will only be returned if a SQL related failure happens.
// In all other cases, a bool and nil will return.
func (p *ProfilesExperiences) Exists(qu Queryer, id int64) (exists bool, err error) {
	const stmt = "SELECT EXISTS(SELECT 1 FROM `profiles__experiences__` WHERE id = ? LIMIT 1) AS `exists`"
	var count int
	row := qu.QueryRow(stmt, id)
	if err = row.Scan(&count); err != nil {
		return
	}
	return count > 0, nil
}

// TableName returns the table name
func (p *ProfilesExperiences) TableName() string {
	return "profiles__experiences__"
}

// SetLimit sets the query limit
func (p *ProfilesExperiences) SetLimit(limit int) *ProfilesExperiences {
	p.limit = limit
	return p
}

// SetOffset sets the query offset
func (p *ProfilesExperiences) SetOffset(offset int) *ProfilesExperiences {
	p.offset = offset
	return p
}
